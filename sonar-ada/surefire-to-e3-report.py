#! /usr/bin/env python

# GNATdashboard
# Copyright (C) 2016-2017, AdaCore
#
# This is free software;  you can redistribute it  and/or modify it  under
# terms of the  GNU General Public License as published  by the Free Soft-
# ware  Foundation;  either version 3,  or (at your option) any later ver-
# sion.  This software is distributed in the hope  that it will be useful,
# but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN-
# TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
# License for  more details.  You should have  received  a copy of the GNU
# General  Public  License  distributed  with  this  software;   see  file
# COPYING3.  If not, go to http://www.gnu.org/licenses for a complete copy
# of the license.

"""Convert a Maven Surefire test report into a E3 test report.

The Maven Surefire plugin generates XML reports for each testsuite executed.
ANOD test framework expects JSON reports, generated by E3 based on the
testsuite results in text format.

This script has been tested with JUnit v4.12 only.

See http://windyroad.com.au/dl/Open%20Source/JUnit.xsd for the complete JUnit
test result schema.

:see: http://windyroad.com.au/dl/Open%20Source/JUnit.xsd
"""

import re
import json
import logging
import os
import sys
import xml.dom.minidom as xml

from collections import namedtuple

# Module logger
LOG = logging.getLogger(__name__)

# The <testsuite> node contains 6 attributes:
#  * name: the name of the testsuite
#  * time: the total execution time of the testsuite
#  * tests: the total number of testcases executed
#  * errors: the total number of testcase errors
#  * skipped: the total number of skipped testcases
#  * failures: the total number of failed testcases
SureFireTestsuite = namedtuple(
    'SureFireTestsuite',
    ('name', 'time', 'tests', 'errors', 'skipped', 'failures')
)

# The <testcase> node contains 3 attributes:
#  * name: the name of the testcase
#  * classname: the name of the class containing the test methods
#  * time: the total execution time of the testcase
SureFireTestcase = namedtuple(
    'SureFireTestcase', ('name', 'classname', 'time')
)

# A <failure> or <error> node contains a required attribute and an optional
# one, as well as the relevant data for the error:
#  * type: the type of error that occured (e.g. java exception for an <error>,
#          or the type of assert for a <failure>)
#  * message: the error message (e.g. the return value of getMessage() if a
#             java exception is thrown for an <error>, or the message
#             specified in the assert for a <failure>)
#  * data: the relevant data for the error, e.g. a stack trace
SureFireTestError = namedtuple(
    'SureFireTestFailureOrError', ('type', 'message', 'data')
)


def list_surefire_xml_reports(input_dir):
    """List all Maven Surefire XML reports in ``input_dir``.

    :param str input_dir: the directory to scan for XML report files
    :return: the list of XML reports found
    :rtype: collections.Iterable[str]
    """
    filenames = [f for f in os.listdir(input_dir)
                 if f.startswith('TEST-') and f.endswith('.xml')]
    return [os.path.join(input_dir, f) for f in filenames]


def get_uniq_child_node_by_name(parent, tagName):
    childNodes = [
        node for node in parent.childNodes
        if node.nodeType == node.ELEMENT_NODE and node.tagName == tagName
    ]
    assert len(childNodes) <= 1, 'maximum one <{}> expected'.format(tagName)
    return childNodes[-1] if childNodes else None


def get_text_content(node):
    """Return the text content of a node.

    The text part of a node is considered a node in itself placed as
    child-nodes. A node can have several text nodes.

    :param node: the node from which to extract the text content
    :type node: xml.dom.Node or None
    :return: the text content of ``node``, if any
    :rtype: str or None
    """
    if node is None:
        return None
    return ' '.join(
        child.nodeValue for child in node.childNodes
        if child.nodeType == child.TEXT_NODE
    )


def get_error(node):
    """Extract the details from a <failure> or <error> node.

    Returns ``None`` if ``node`` is ``None``.

    :param node: the node to extract information from
    :type node: xml.dom.Node or None
    :return: the extracted data, if any
    :rtype: SureFireError or None
    """
    def error_attr_value(node, name):
        if name == 'type':
            type = node.attributes['type'].value
            if type[-1] == ':':
                type = type[:-1]
            return type
        else:
            return (node.attributes[name].value if node.hasAttribute(name)
                    else None)

    if node is None:
        return None

    return SureFireTestError(
        type=error_attr_value(node, 'type'),
        message=error_attr_value(node, 'message'),
        data=get_text_content(node)
    )


def parse_testcase_node(testcase_node):
    """Parse a <testcase> node from a Maven Surefire XML testsuite report.

    :param xml.dom.Node testcase_node: the XML node to parse
    :return: the parsed testcase report
    :rtype: SureFireTestcase, SureFireFailure or None, SureFireError
    """
    def testcase_attr_value(name, value):
        if name == 'time':
            return float(value)
        else:
            return value

    testcase = SureFireTestcase(**{
        name: testcase_attr_value(name, value)
        for name, value in list(testcase_node.attributes.items())
    })
    LOG.info('Parsing testcase %s', testcase.name)
    error_node = get_uniq_child_node_by_name(testcase_node, 'error')
    failure_node = get_uniq_child_node_by_name(testcase_node, 'failure')
    skipped_node = get_uniq_child_node_by_name(testcase_node, 'skipped')

    return (
        testcase, skipped_node is not None,
        get_error(failure_node), get_error(error_node)
    )


def parse_surefire_xml_report(report_path):
    """Parse a Maven Surefire XML testsuite report.

    See http://windyroad.com.au/dl/Open%20Source/JUnit.xsd for the complete
    JUnit test result schema.

    :param str report_path: the path to the report file
    :return: the parsed testsuite report
    :rtype: SureFireTestsuite
    """
    # Get the <testsuite> root element of the Surefire report
    LOG.info('Parsing XML report %s', report_path)
    testsuite_node = xml.parse(report_path).documentElement

    def testsuite_attr_value(name, value):
        if name == 'name':
            return value
        elif name == 'time':
            return float(value)
        else:
            return int(value)

    testsuite = SureFireTestsuite(**{
        name: testsuite_attr_value(name, value)
        for name, value in list(testsuite_node.attributes.items()) if
        ':' not in name
    })
    LOG.info(json.dumps(testsuite._asdict(), indent=2))

    # List all <testcase> nodes within the <testsuite> node
    testcases = [
        parse_testcase_node(node) for node in testsuite_node.childNodes
        if node.nodeType == node.ELEMENT_NODE and node.tagName == 'testcase'
    ]
    assert testsuite.tests == len(testcases), 'inconsistent total of testcases'
    LOG.info('Found %d testcase(s) in testsuite %s',
             testsuite.tests, testsuite.name)

    # Get the <system-out> and <system-err> node if they exist
    stdout_node = get_uniq_child_node_by_name(testsuite_node, 'system-out')
    stderr_node = get_uniq_child_node_by_name(testsuite_node, 'system-err')

    return (
        testsuite, testcases,
        get_text_content(stdout_node), get_text_content(stderr_node)
    )


def generate_e3_report(output_dir, testsuites):
    def test_name(testsuite, testcase):
        return re.sub(
            r'-+$',
            '',
            re.sub(
                r'[^\w.]',
                '-',
                '{}.{}'.format(testsuite.name, testcase.name)))

    def resource(testsuite, testcase, ext):
        return os.path.join(
            output_dir, '{}.{}'.format(test_name(testsuite, testcase), ext))

    def one_line_error_message(error):
        return (
            '{}: {}'.format(error.type, error.message.splitlines()[0]) if error.message
            else error.type)

    def error_message(error):
        return (
            '{}: {}'.format(error.type, error.message) if error.message
            else error.type)

    def nl(string, count=1):
        return '{}{}'.format(string or '', '\n' * count)

    results = []
    for testsuite, testcases, _, _ in testsuites:
        for testcase, skipped, failure, error in testcases:
            if skipped:
                result = 'DEAD:test was skipped'
            elif failure:
                result = 'FAILED:{}'.format(one_line_error_message(failure))
            elif error:
                result = 'CRASH:{}'.format(one_line_error_message(error))
            else:
                result = 'OK:'
            result = nl(result)
            results.append(
                '{}:{}'.format(test_name(testsuite, testcase), result))

            # Generate the .result file
            with open(resource(testsuite, testcase, 'result'), 'w') as out:
                out.write(result)
            # Generate the .time file
            with open(resource(testsuite, testcase, 'time'), 'w') as out:
                out.write(nl(str(testcase.time)))
            # Generate the .out and .diff file on error
            if failure or error:
                for ext in 'out', 'diff':
                    with open(resource(testsuite, testcase, ext), 'w') as out:
                        out.write(nl(error_message(failure or error)))

    # Generate the 'results' file
    with open(os.path.join(output_dir, 'results'), 'w') as out:
        out.write(''.join(results))

    # Generate the 'report' file
    stats = {
        'tests': sum([ts[0].tests for ts in testsuites]),
        'success': (
            sum([ts[0].tests for ts in testsuites])
            - sum([ts[0].failures for ts in testsuites])
            - sum([ts[0].errors for ts in testsuites])
            - sum([ts[0].skipped for ts in testsuites])),
        'failures': sum([ts[0].failures for ts in testsuites]),
        'errors': sum([ts[0].errors for ts in testsuites]),
        'skipped': sum([ts[0].skipped for ts in testsuites]),
        'elapsed': sum([ts[0].time for ts in testsuites])
    }

    with open(os.path.join(output_dir, 'report'), 'w') as out:
        out.write(nl('\n'.join(['-' * 55, ' T E S T S', '-' * 55]), count=2))
        out.write(nl('\n'.join([
            'Tests run: {tests}, Failures: {failures}, Errors: {errors}, '
            'Skipped: {skipped}, Time elapsed: {elapsed} sec - {ts}'.format(**{
                'ts': ts.name,
                'tests': ts.tests,
                'failures': ts.failures,
                'errors': ts.errors,
                'skipped': ts.skipped,
                'elapsed': ts.time
            }) for ts, _, _, _ in testsuites]), count=2))
        out.write(nl('Results:', count=2))

        if stats['skipped']:
            skipped = ['  {}.{}'.format(ts.name, t.name)
                       for ts, tc, _, _ in testsuites
                       for t, skipped, _, _ in tc if skipped]
            out.write(nl('Skipped tests:'))
            out.write(nl('\n'.join(skipped), count=2))

        if stats['failures']:
            failures = ['  {}.{}'.format(ts.name, t.name)
                        for ts, tc, _, _ in testsuites
                        for t, _, failed, _ in tc if failed]
            out.write(nl('Failed tests:'))
            out.write(nl('\n'.join(failures), count=2))

        if stats['errors']:
            errors = ['  {}.{}'.format(ts.name, t.name)
                      for ts, tc, _, _ in testsuites
                      for t, _, _, errors in tc if errors]
            out.write(nl('Tests in error:'))
            out.write(nl('\n'.join(errors), count=2))

        out.write(nl(
            'Tests run: {tests}, Failures: {failures}, Errors: {errors}, '
            'Skipped: {skipped}, Time elapsed: {elapsed} sec'.format(**stats)))


def surefire_to_e3_report(input_dir, output_dir):
    LOG.info('Scanning Surefire report directory: %s', input_dir)
    sf_reports = list_surefire_xml_reports(input_dir)
    LOG.info('Found %d XML report(s)', len(sf_reports))

    # Create the output directory if missing
    if not os.path.isdir(output_dir):
        return '%s: no such directory'.format(output_dir)

    # Parse Maven Surefire XML reports
    testsuites = [parse_surefire_xml_report(r) for r in sf_reports]
    # Generate E3 reports
    generate_e3_report(output_dir, testsuites)
    return 0


def enable_debug_mode():
    """Activate the DEBUG mode (ie. console logging)."""
    logging.basicConfig(
        level=logging.DEBUG, format='[%(levelname)s] %(message)s')


if __name__ == '__main__':
    import argparse
    main = argparse.ArgumentParser(
        description='Convert MavenSurefire test report into E3 report')
    main.add_argument(
        '-i', '--input', metavar='SUREFIRE_REPORT_DIR', required=True,
        help='the input Surefire test reports directory')
    main.add_argument(
        '-o', '--output', metavar='E3_REPORT_dir', required=True,
        help='the output E3 test reports directory')
    main.add_argument(
        '-d', '--debug', default=False, action='store_true',
        help=argparse.SUPPRESS)
    args = main.parse_args()

    if args.debug:
        enable_debug_mode()

    sys.exit(surefire_to_e3_report(args.input, args.output))
